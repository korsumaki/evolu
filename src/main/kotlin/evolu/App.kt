/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package evolu

import kotlin.collections.ArrayList
import kotlin.random.Random

class App {
    val greeting: String
        get() {
            return "Hello world."
        }
}

/*
* + Field
* - Robot
*     - Position, direction
*     - Genome
*       - String[54]
*     - Statistics
*       - collected diamonds
*       - used steps
*     - Cpu
*
* */

fun main() {
    println("Evolution starts now...")
    val stepLimit = 1000
    val robotCount = 1000
    val fieldCount = 100

    val robotList = ArrayList<Robot>(robotCount)
    val fieldList = ArrayList<Field>(fieldCount)

    val origField = Field(7,7)
    origField.randomize()

    println("Creating $fieldCount fields...")
    repeat (fieldCount) {
        val field = Field(7,7)
        field.randomize()
        fieldList.add(field)
    }

    println("Creating $robotCount robots...")
    repeat (robotCount) {
        val copyField = origField.copy()
        val robot = Robot(copyField)
        robotList.add(robot)
    }

    // ========================

    val progressStep = fieldList.size / 100
    val progressNumberStep = fieldList.size / 10
    repeat(30) {
        // One generation
        print("Testing fields: ")
        for ((fieldIndex, field) in fieldList.withIndex()) {

            // Progress indicator
            if ((fieldIndex+1) % progressStep == 0) {
                if ((fieldIndex+1) % progressNumberStep == 0) {
                    print( 10*(fieldIndex+1)/progressNumberStep)
                }
                else {
                    print('.')
                }
            }

            for (robot in robotList) {
                robot.field = field.copy()
                robot.randomizePosition()
                robot.randomizeDirection()
                robot.statistics = Statistics()

                // run code until instruction limit or all diamonds found
                while (robot.field.numOfDiamondsLeft > 0 && robot.statistics.usedSteps < stepLimit) {
                    val spotCode = robot.field.getSpotCode(robot.currentPosition, robot.currentDirection)
                    robot.execute(spotCode)
                }

                robot.statisticsAllTime += robot.statistics
                //println("End. ${robot.field.numOfDiamondsLeft} diamonds left. Used steps ${robot.statistics.usedSteps}")
            }
        }
        println()

        // ========================
        // print statistics
        println("Statistics for round ${it+1}, sorted")
        robotList.sortBy { it.statisticsAllTime.executionErrors }
        robotList.sortBy { it.statisticsAllTime.usedSteps }
        robotList.sortByDescending { it.statisticsAllTime.diamondsCollected }
        for ((index, robot) in robotList.withIndex()) {
            println("#$index: diamonds=${robot.statisticsAllTime.diamondsCollected.toDouble()/fieldCount}, " +
                    "steps=${robot.statisticsAllTime.usedSteps.toDouble()/fieldCount}, " +
                    "errors=${robot.statisticsAllTime.executionErrors.toDouble()/fieldCount}, " +
                    "Genome: ${robot.genome}")
        }

        // Get best from this generation, and create next generation
        val tempRobots = robotList.subList(0, robotList.size/3) // Take best third

        println("Creating next generation robots...")
        for (robot in robotList) {
            robot.statisticsAllTime = Statistics()
            robot.genome = robot.generateGenome(
                tempRobots[Random.nextInt(tempRobots.size)].genome,
                tempRobots[Random.nextInt(tempRobots.size)].genome
            )
        }
    }
}
